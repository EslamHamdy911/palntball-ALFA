<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEON WARS: Final Fix</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * { touch-action: none; -webkit-touch-callout: none; -webkit-user-select: none; user-select: none; outline: none; -webkit-tap-highlight-color: transparent; }
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Orbitron', sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 5, 10, 0.98);
            display: flex; flex-direction: column;
            justify-content: center; align-items: center; 
            pointer-events: auto; z-index: 100;
        }
        
        h1 { color: #00f3ff; text-shadow: 0 0 20px #00f3ff; font-size: 35px; margin: 0; text-align: center;}
        p { color: #aaa; margin-top: 5px; font-size: 12px; }

        .btn {
            background: rgba(0, 243, 255, 0.1); border: 2px solid #00f3ff; color: #00f3ff;
            padding: 15px 40px; font-size: 20px; font-family: 'Orbitron', sans-serif;
            cursor: pointer; margin-top: 25px; text-transform: uppercase; width: 70%; border-radius: 10px;
            box-shadow: 0 0 15px #00f3ff; pointer-events: auto;
        }
        .btn:active { background: #00f3ff; color: #000; transform: scale(0.95); }

        /* Ø²Ø± Ø§Ù„ØºØ¶Ø¨ */
        #rage-btn {
            position: absolute; bottom: 50px; right: 20px; /* ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù…ÙƒØ§Ù† */
            width: 90px; height: 90px; border-radius: 50%;
            background: radial-gradient(circle, #ff5500, #550000);
            border: 4px solid #ffaa00;
            color: #fff; font-weight: bold; font-size: 16px;
            display: none; 
            justify-content: center; align-items: center;
            box-shadow: 0 0 20px #ff5500;
            animation: pulseRage 0.5s infinite alternate;
            pointer-events: auto; cursor: pointer; z-index: 200; /* Ø±ÙØ¹ Ø§Ù„Ø·Ø¨Ù‚Ø© */
        }
        @keyframes pulseRage { from { transform: scale(1); box-shadow: 0 0 20px #ff5500; } to { transform: scale(1.1); box-shadow: 0 0 40px #ff5500; } }

        #hud { padding: 15px; display: flex; justify-content: space-between; width: 90%; margin: 0 auto; text-shadow: 0 2px 5px rgba(0,0,0,0.8); font-size: 16px; font-weight: bold; }
        #wave-msg { position: absolute; top: 15%; width: 100%; text-align: center; color: #f1c40f; font-size: 24px; font-weight: bold; opacity: 0; transition: opacity 0.5s; text-shadow: 0 0 10px #f00; }
        
        #rage-timer { position: absolute; top: 60px; right: 20px; color: #ff5500; font-size: 14px; font-weight: bold;}
    </style>
</head>
<body>

    <div id="start-screen" class="screen">
        <h1>NEON WARS</h1>
        <p>SYSTEM REBOOTED</p>
        <button class="btn" onclick="startGame()">START</button>
        <p style="margin-top: 20px; font-size: 10px; color: #666;">MOVE TO SHOOT</p>
    </div>

    <div id="win-screen" class="screen" style="display:none;">
        <h1 style="color:#f1c40f">VICTORY</h1>
        <button class="btn" onclick="location.reload()">RESTART</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div id="hud">
            <div style="color:#00f3ff">SCORE: <span id="p-score">0</span></div>
            <div style="color:#ff0055">HP: <span id="p-hp">100</span>%</div>
        </div>
        <div id="wave-msg">WARNING</div>
        <div id="rage-timer">RAGE: <span id="r-time">0</span>%</div>
        
        <!-- Ø²Ø± Ø§Ù„ØºØ¶Ø¨ -->
        <div id="rage-btn">RAGE!</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        function resize() {
            width = window.innerWidth; height = window.innerHeight;
            canvas.width = width; canvas.height = height;
        }
        window.addEventListener('resize', resize); resize();

        let gameRunning = false;
        let score = 0;
        let frame = 0;
        
        let enemies = [], bullets = [], particles = [];
        let player;
        let shake = 0;
        
        let bossPhase = 0; // 0:Ø¨Ø¯Ø§ÙŠØ©, 1:ÙˆØ­Ø´1, 2:ØªÙˆØ£Ù…, 3:Ø²ÙˆÙ…Ø¨ÙŠ
        
        let rageCharge = 0;
        let isRageActive = false;
        let rageDuration = 0;

        const input = {
            active: false,
            startX: 0, startY: 0,
            x: 0, y: 0,
            dx: 0, dy: 0,
            id: null
        };

        class Agent {
            constructor(x, y, type) {
                this.x = x; this.y = y; this.type = type; 
                this.angle = 0;
                
                if(type === 'player') {
                    this.radius = 15; this.color = '#00f3ff'; this.speed = 4; this.hp = 200; this.maxHp = 200;
                } else if (type === 'boss') {
                    this.radius = 40; this.color = '#f1c40f'; this.speed = 1.5; this.hp = 500; this.maxHp = 500;
                } else if (type === 'zombie') {
                    this.radius = 15; this.color = '#00ff00'; this.speed = 5; this.hp = 20;
                } else { 
                    this.radius = 15; this.color = '#ff0055'; this.speed = 2.5; this.hp = 30;
                }
            }

            update() {
                let dx=0, dy=0;
                if (this.type === 'player') {
                    if (input.active) {
                        dx = input.dx; dy = input.dy;
                        // Auto-Aim logic
                        let nearest = null; let minDst = 9999;
                        enemies.forEach(e => {
                            let d = Math.hypot(e.x - this.x, e.y - this.y);
                            if(d < minDst) { minDst = d; nearest = e; }
                        });
                        if(nearest && minDst < 500) {
                            this.angle = Math.atan2(nearest.y - this.y, nearest.x - this.x);
                        } else if (dx || dy) {
                            this.angle = Math.atan2(dy, dx);
                        }
                        let rate = isRageActive ? 5 : 12; 
                        if(frame % rate === 0) shoot(this);
                    }
                } else {
                    let target = player;
                    let dist = Math.hypot(target.x - this.x, target.y - this.y);
                    this.angle = Math.atan2(target.y - this.y, target.x - this.x);

                    if(this.type === 'zombie') {
                        dx = Math.cos(this.angle); dy = Math.sin(this.angle);
                        if(dist < this.radius + target.radius) {
                            player.hp -= 0.5; createExplosion(this.x, this.y, '#f00', 1);
                        }
                    } else {
                        let stopDist = (this.type === 'boss') ? 250 : 150;
                        if(dist > stopDist) { dx = Math.cos(this.angle); dy = Math.sin(this.angle); }
                        else if(dist < stopDist - 50) { dx = -Math.cos(this.angle); dy = -Math.sin(this.angle); }
                        
                        enemies.forEach(other => {
                            if(other !== this && Math.hypot(this.x - other.x, this.y - other.y) < this.radius + other.radius) {
                                dx += (this.x - other.x) * 0.05; dy += (this.y - other.y) * 0.05;
                            }
                        });

                        let shootProb = (this.type === 'boss') ? 0.03 : 0.02;
                        if(Math.random() < shootProb) shoot(this);
                    }
                }
                this.x += dx * this.speed; this.y += dy * this.speed;
                this.x = Math.max(20, Math.min(width-20, this.x));
                this.y = Math.max(20, Math.min(height-20, this.y));
            }

            draw() {
                ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
                let drawColor = (this.type === 'player' && isRageActive) ? '#ff4400' : this.color;
                ctx.shadowBlur = 10; ctx.shadowColor = drawColor;
                ctx.fillStyle = drawColor; ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI*2); ctx.fill();
                ctx.shadowBlur = 0; ctx.fillStyle = '#111';
                
                if(this.type === 'boss') {
                    ctx.fillRect(15, -30, 40, 60); ctx.beginPath(); ctx.arc(0, 0, 25, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = 'red'; ctx.fillRect(-30, -50, 60, 4);
                    ctx.fillStyle = '#0f0'; ctx.fillRect(-30, -50, 60 * (this.hp/this.maxHp), 4);
                } else if(this.type === 'zombie') {
                     ctx.beginPath(); ctx.arc(5, -5, 4, 0, Math.PI*2); ctx.fill();
                     ctx.beginPath(); ctx.arc(5, 5, 4, 0, Math.PI*2); ctx.fill();
                } else {
                    ctx.fillRect(5, -5, 15, 10);
                }
                ctx.restore();
            }
        }

        function spawnEnemy(type = 'enemy', xOffset = 0) {
            let startX = width/2 + xOffset;
            let startY = -50;
            if(type === 'zombie') {
                startX = Math.random() < 0.5 ? -20 : width+20;
                startY = Math.random() * height;
            } else if (type === 'enemy') {
                startX = Math.random() * width;
            }
            let e = new Agent(startX, startY, type);
            enemies.push(e);
        }

        function shoot(s) {
            let shots = [];
            if(s.type === 'player') {
                if(isRageActive) { shots.push(s.angle, s.angle-0.2, s.angle+0.2); } 
                else { shots.push(s.angle); }
            } else if(s.type === 'boss') {
                shots.push(s.angle, s.angle-0.3, s.angle+0.3);
            } else {
                shots.push(s.angle + (Math.random()-0.5)*0.1);
            }
            shots.forEach(a => {
                let size = (s.type === 'player' && isRageActive) ? 6 : 3;
                let dmg = (s.type === 'player') ? (isRageActive ? 20 : 10) : 5;
                bullets.push({
                    x: s.x, y: s.y, vx: Math.cos(a)*10, vy: Math.sin(a)*10, 
                    color: (s.type === 'player' && isRageActive) ? '#ff4400' : s.color, 
                    owner: s.type === 'player' ? 'p' : 'e', size: size, damage: dmg
                });
            });
        }

        function createExplosion(x, y, color, count=10) {
            for(let i=0; i<count; i++) particles.push({x, y, vx:(Math.random()-0.5)*8, vy:(Math.random()-0.5)*8, life:1, color});
        }

        function showMsg(text) {
            let el = document.getElementById('wave-msg'); el.innerText = text; el.style.opacity = 1; setTimeout(() => el.style.opacity = 0, 3000);
        }

        // --- Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù„Ø¹Ø¨Ø© ÙˆØ§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¹Ø¯Ù… ÙØ±Ø§Øº Ø§Ù„Ø´Ø§Ø´Ø© ---
        function maintainEnemies() {
            // Ø¥Ø°Ø§ ÙƒÙ†Ø§ ÙÙŠ Ù…Ø¹Ø±ÙƒØ© ÙˆØ­Ø´ØŒ Ù„Ø§ ØªØ¶Ù Ø£Ø¹Ø¯Ø§Ø¡ Ø¹Ø§Ø¯ÙŠÙŠÙ†
            if(bossPhase === 1 || bossPhase === 2) return;

            let targetCount = 3 + Math.floor(score/50); // ÙŠØ²ÙŠØ¯ Ø§Ù„Ø¹Ø¯Ø¯ Ù…Ø¹ Ø§Ù„Ù†Ù‚Ø§Ø·
            
            // Ø¥Ø°Ø§ Ù‚Ù„ Ø§Ù„Ø¹Ø¯Ø¯ Ø¹Ù† Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ØŒ Ø£Ø¶Ù Ø¹Ø¯ÙˆØ§Ù‹
            if(enemies.length < targetCount) {
                // Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ ÙÙˆØ±ÙŠ Ø¥Ø°Ø§ Ø§Ù„Ø´Ø§Ø´Ø© ÙØ§Ø±ØºØ© ØªÙ…Ø§Ù…Ø§Ù‹
                if(enemies.length === 0) {
                    spawnEnemy(bossPhase === 3 ? 'zombie' : 'enemy');
                } 
                // Ø§Ø­ØªÙ…Ø§Ù„ÙŠØ© Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ ÙÙŠ ÙƒÙ„ ÙØ±ÙŠÙ… (Ù„ØªØ¹Ø¨Ø¦Ø© Ø§Ù„Ø´Ø§Ø´Ø© ØªØ¯Ø±ÙŠØ¬ÙŠØ§Ù‹)
                else if(Math.random() < 0.05) {
                    spawnEnemy(bossPhase === 3 ? 'zombie' : 'enemy');
                }
            }
        }

        function checkProgression() {
            // Ø§Ù„Ù…Ø±Ø­Ù„Ø© 1: ÙˆØ­Ø´ 1 Ø¹Ù†Ø¯ 100 Ù†Ù‚Ø·Ø©
            if(score >= 100 && bossPhase === 0) {
                bossPhase = 1; showMsg("âš ï¸ BOSS DETECTED âš ï¸");
                enemies = []; setTimeout(() => spawnEnemy('boss'), 1000);
            }
            // Ø§Ù„Ù…Ø±Ø­Ù„Ø© 2: Ø§Ù„ØªÙˆØ£Ù… Ø¨Ø¹Ø¯ Ù…ÙˆØª Ø§Ù„ÙˆØ­Ø´ Ø§Ù„Ø£ÙˆÙ„
            else if(bossPhase === 1 && enemies.length === 0) {
                bossPhase = 2; showMsg("âš ï¸ THE TWINS âš ï¸");
                setTimeout(() => { spawnEnemy('boss', -60); spawnEnemy('boss', 60); }, 2000);
            }
            // Ø§Ù„Ù…Ø±Ø­Ù„Ø© 3: Ø§Ù„Ø²ÙˆÙ…Ø¨ÙŠ Ø¨Ø¹Ø¯ Ù…ÙˆØª Ø§Ù„ØªÙˆØ£Ù…
            else if(bossPhase === 2 && enemies.length === 0 && score > 200) {
                bossPhase = 3; showMsg("â˜£ï¸ ZOMBIE HORDE â˜£ï¸");
            }
        }

        // --- Rage System ---
        function activateRage() {
            isRageActive = true;
            rageDuration = 600; 
            rageCharge = 0;
            document.getElementById('rage-btn').style.display = 'none';
            showMsg("ğŸ”¥ğŸ”¥ RAGE UNLEASHED ğŸ”¥ğŸ”¥");
            createExplosion(player.x, player.y, '#ff4400', 50);
            // Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ ÙÙˆØ±ÙŠ Ù„Ø²ÙˆÙ…Ø¨ÙŠ
            for(let i=0; i<6; i++) setTimeout(() => spawnEnemy('zombie'), i*300);
        }

        function updateRage() {
            if(isRageActive) {
                rageDuration--;
                if(rageDuration <= 0) { isRageActive = false; }
            } else {
                if(rageCharge < 100) rageCharge += (100 / 1800); // ÙŠØ´Ø­Ù† ÙÙŠ 30 Ø«Ø§Ù†ÙŠØ©
                document.getElementById('r-time').innerText = Math.floor(rageCharge);
                if(rageCharge >= 100) document.getElementById('rage-btn').style.display = 'flex';
            }
        }

        function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            player = new Agent(width/2, height-100, 'player');
            enemies = []; bullets = []; score = 0; bossPhase = 0; rageCharge = 100; // Ø§Ø¨Ø¯Ø£ Ø¨Ø´Ø­Ù† ÙƒØ§Ù…Ù„ Ù„Ù„ØªØ¬Ø±Ø¨Ø©
            gameRunning = true; 
            spawnEnemy(); 
            loop();
        }

        function loop() {
            if(!gameRunning) return;
            requestAnimationFrame(loop); frame++;
            
            if(shake > 0) { ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake); shake *= 0.9; }

            ctx.fillStyle = '#050505'; ctx.fillRect(0,0,width,height);
            ctx.strokeStyle = 'rgba(0, 243, 255, 0.05)'; ctx.lineWidth = 1; ctx.beginPath();
            for(let i=0; i<width; i+=80) { ctx.moveTo(i,0); ctx.lineTo(i,height); }
            for(let i=0; i<height; i+=80) { ctx.moveTo(0,i); ctx.lineTo(width,i); }
            ctx.stroke();

            updateRage();
            maintainEnemies(); // Ø§Ù„ØªØ£ÙƒØ¯ Ø§Ù„Ù…Ø³ØªÙ…Ø± Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø£Ø¹Ø¯Ø§Ø¡

            for(let i=particles.length-1; i>=0; i--) {
                let p = particles[i]; p.x += p.vx; p.y += p.vy; p.life -= 0.05;
                ctx.globalAlpha = p.life; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, 2, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1; if(p.life<=0) particles.splice(i,1);
            }

            if(player) player.update(); player.draw();
            enemies.forEach(e => { e.update(); e.draw(); });

            for(let i=bullets.length-1; i>=0; i--) {
                let b = bullets[i]; b.x += b.vx; b.y += b.vy;
                ctx.strokeStyle = b.color; ctx.lineWidth = b.size; ctx.beginPath(); ctx.moveTo(b.x, b.y); ctx.lineTo(b.x-b.vx, b.y-b.vy); ctx.stroke();
                
                if(b.x<0||b.x>width||b.y<0||b.y>height) { bullets.splice(i,1); continue; }

                let targets = (b.owner === 'p') ? enemies : [player];
                for(let t of targets) {
                    if(Math.hypot(b.x-t.x, b.y-t.y) < t.radius+5) {
                        createExplosion(t.x, t.y, b.color, 3);
                        if(b.owner === 'p') {
                            t.hp -= b.damage;
                            if(t.hp <= 0) {
                                score += (t.type==='boss'?50:5); 
                                createExplosion(t.x, t.y, '#fff', 10);
                                enemies = enemies.filter(e => e !== t);
                                checkProgression();
                            }
                        } else {
                            player.hp -= 2; shake = 5;
                            if(player.hp <= 0) location.reload();
                        }
                        bullets.splice(i,1); break;
                    }
                }
            }

            document.getElementById('p-score').innerText = score;
            document.getElementById('p-hp').innerText = Math.max(0, Math.floor((player.hp/player.maxHp)*100));

            if (input.active) {
                ctx.beginPath(); ctx.arc(input.startX, input.startY, 40, 0, Math.PI*2);
                ctx.strokeStyle = 'rgba(255,255,255,0.1)'; ctx.stroke();
                ctx.beginPath(); ctx.arc(input.x, input.y, 20, 0, Math.PI*2);
                ctx.fillStyle = 'rgba(0, 243, 255, 0.4)'; ctx.fill();
            }

            ctx.restore();
        }

        // --- Rage Button Listener ---
        const rageBtn = document.getElementById('rage-btn');
        rageBtn.addEventListener('touchstart', (e) => {
            e.stopPropagation(); // Ù…Ù†Ø¹ Ø§Ù†ØªÙ‚Ø§Ù„ Ø§Ù„Ù„Ù…Ø³ Ù„Ù„Ø¹Ø¨Ø©
            activateRage();
        });
        rageBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            activateRage();
        });

        // --- Joystick Logic ---
        window.addEventListener('touchstart', e => {
            if(e.target.tagName === 'BUTTON' || e.target.id === 'rage-btn') return;
            e.preventDefault();
            if(!input.active) {
                let t = e.changedTouches[0];
                input.active = true;
                input.id = t.identifier;
                input.startX = t.clientX; input.startY = t.clientY;
                input.x = t.clientX; input.y = t.clientY;
            }
        }, {passive: false});

        window.addEventListener('touchmove', e => {
            if(e.target.tagName !== 'BUTTON' && e.target.id !== 'rage-btn') e.preventDefault();
            for(let i=0; i<e.changedTouches.length; i++) {
                let t = e.changedTouches[i];
                if(input.active && t.identifier === input.id) {
                    let dx = t.clientX - input.startX;
                    let dy = t.clientY - input.startY;
                    let dist = Math.min(40, Math.hypot(dx, dy));
                    let angle = Math.atan2(dy, dx);
                    input.x = input.startX + Math.cos(angle) * dist;
                    input.y = input.startY + Math.sin(angle) * dist;
                    input.dx = Math.cos(angle) * (dist/40);
                    input.dy = Math.sin(angle) * (dist/40);
                }
            }
        }, {passive: false});

        window.addEventListener('touchend', e => {
             for(let i=0; i<e.changedTouches.length; i++) {
                if(e.changedTouches[i].identifier === input.id) {
                    input.active = false; input.dx = 0; input.dy = 0;
                }
             }
        }, {passive: false});

    </script>
</body>
</html>