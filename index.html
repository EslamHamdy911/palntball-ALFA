<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEON WARS: OVERDRIVE</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;900&display=swap" rel="stylesheet">
    <style>
        /* --- ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿäÿßÿ™ ŸàÿßŸÑÿ™ÿ£ÿ´Ÿäÿ±ÿßÿ™ ÿßŸÑÿ®ÿµÿ±Ÿäÿ© --- */
        * { touch-action: none; user-select: none; -webkit-tap-highlight-color: transparent; font-family: 'Orbitron', sans-serif; }
        body { margin: 0; overflow: hidden; background-color: #050505; }
        
        /* ÿ™ÿ£ÿ´Ÿäÿ± ÿßŸÑÿ¥ÿßÿ¥ÿ© ÿßŸÑŸÇÿØŸäŸÖÿ© CRT */
        body::after {
            content: ""; position: absolute; top: 0; left: 0; width: 100vw; height: 100vh;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%; pointer-events: none; z-index: 999;
        }

        canvas { display: block; width: 100vw; height: 100vh; }

        /* Ÿàÿßÿ¨Ÿáÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }

        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            pointer-events: auto; z-index: 100; transition: 0.3s;
        }

        h1 { color: #00f3ff; text-shadow: 0 0 20px #00f3ff; font-size: 40px; margin: 0; text-align: center; letter-spacing: 5px; font-weight: 900; }
        p { color: #aaa; font-size: 14px; margin-top: 10px; }

        .btn {
            background: rgba(0, 243, 255, 0.1); border: 2px solid #00f3ff; color: #00f3ff;
            padding: 15px 40px; font-size: 20px; cursor: pointer; margin-top: 20px; 
            text-transform: uppercase; width: 80%; max-width: 300px; border-radius: 5px;
            box-shadow: 0 0 15px #00f3ff; pointer-events: auto; transition: 0.1s;
        }
        .btn:active { background: #00f3ff; color: #000; transform: scale(0.95); }

        /* ÿ¥ÿ±Ÿäÿ∑ ÿßŸÑÿÆÿ®ÿ±ÿ© (XP Bar) */
        #xp-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 10px; background: #222;
        }
        #xp-fill {
            height: 100%; width: 0%; background: #00ff00; 
            box-shadow: 0 0 10px #00ff00; transition: width 0.2s;
        }
        #level-badge {
            position: absolute; top: 15px; left: 50%; transform: translateX(-50%);
            color: #fff; font-size: 20px; font-weight: bold; text-shadow: 0 0 5px #000;
        }

        /* ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ™ÿ±ŸÇŸäÿ© (Level Up) */
        #upgrade-screen { display: none; background: rgba(0,0,0,0.95); z-index: 200; }
        .card-container { display: flex; flex-direction: column; gap: 15px; width: 90%; max-width: 400px; }
        .upgrade-card {
            background: rgba(255,255,255,0.05); border: 1px solid #fff; padding: 15px;
            cursor: pointer; pointer-events: auto; display: flex; align-items: center; gap: 15px;
            transition: 0.2s;
        }
        .upgrade-card:active { background: #fff; color: #000; }
        .icon { font-size: 30px; }
        .desc h3 { margin: 0; color: #ffd700; font-size: 18px; }
        .desc span { font-size: 12px; color: #ccc; }

        /* HUD */
        #hud { position: absolute; bottom: 20px; left: 20px; color: #fff; font-size: 14px; }
        #hp-bar-con { width: 150px; height: 10px; background: #333; margin-top: 5px; border: 1px solid #555; }
        #hp-fill { width: 100%; height: 100%; background: #ff0055; transition: width 0.2s; }

        #joystick-zone { position: absolute; bottom: 50px; left: 50px; width: 100px; height: 100px; pointer-events: none; opacity: 0.5; }
    </style>
</head>
<body>

    <!-- ÿ¥ÿßÿ¥ÿ© ÿßŸÑÿ®ÿØÿßŸäÿ© -->
    <div id="start-screen" class="screen">
        <h1>NEON<br>OVERDRIVE</h1>
        <p>V2.0 - ROGUELITE EDITION</p>
        <button class="btn" onclick="startGame()">SYSTEM LINK</button>
        <p style="font-size: 10px; color: #555; margin-top: 30px;">COLLECT ORBS TO UPGRADE</p>
    </div>

    <!-- ÿ¥ÿßÿ¥ÿ© ÿßŸÑÿ™ÿ±ŸÇŸäÿ© -->
    <div id="upgrade-screen" class="screen">
        <h1 style="font-size: 30px; color: #ffd700;">LEVEL UP!</h1>
        <p>CHOOSE AN UPGRADE</p>
        <div class="card-container" id="cards-box">
            <!-- ÿßŸÑŸÉÿ±Ÿàÿ™ ÿ≥ÿ™ÿ∏Ÿáÿ± ŸáŸÜÿß ÿ®ÿßŸÑŸÉŸàÿØ -->
        </div>
    </div>

    <!-- ÿ¥ÿßÿ¥ÿ© ÿßŸÑŸÖŸàÿ™ -->
    <div id="game-over-screen" class="screen" style="display:none;">
        <h1 style="color: #ff0055;">CRITICAL ERROR</h1>
        <p>SCORE: <span id="final-score">0</span> | LEVEL: <span id="final-level">1</span></p>
        <button class="btn" onclick="location.reload()">REBOOT</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div id="xp-container"><div id="xp-fill"></div></div>
        <div id="level-badge">LVL <span id="lvl-txt">1</span></div>
        
        <div id="hud">
            <div>HP SYSTEM</div>
            <div id="hp-bar-con"><div id="hp-fill"></div></div>
            <div style="margin-top: 5px; color: #00f3ff;">KILLS: <span id="kill-count">0</span></div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // === ŸÖŸàÿ≥ŸäŸÇŸâ (ÿßÿÆÿ™Ÿäÿßÿ±Ÿä) ===
        // ÿ™ÿ£ŸÉÿØ ŸÖŸÜ Ÿàÿ¨ŸàÿØ ŸÖŸÑŸÅ music.mp3 ÿ®ÿ¨ÿßŸÜÿ® ÿßŸÑŸÖŸÑŸÅ
        const bgMusic = new Audio('music.mp3'); 
        bgMusic.loop = true; bgMusic.volume = 0.4;

        let width, height;
        function resize() {
            width = window.innerWidth; height = window.innerHeight;
            canvas.width = width; canvas.height = height;
        }
        window.addEventListener('resize', resize); resize();

        // === ÿ≠ÿßŸÑÿ© ÿßŸÑŸÑÿπÿ®ÿ© ===
        let gameState = 'START'; // START, PLAY, UPGRADE, OVER
        let frame = 0;
        let score = 0;
        let kills = 0;

        // === ÿßŸÑŸÑÿßÿπÿ® ŸàÿßŸÑÿ™ÿ±ŸÇŸäÿßÿ™ ===
        const player = {
            x: 0, y: 0, radius: 15, angle: 0,
            hp: 100, maxHp: 100,
            speed: 4,
            level: 1, xp: 0, nextLevelXp: 50,
            // ÿÆÿµÿßÿ¶ÿµ ÿßŸÑÿ≥ŸÑÿßÿ≠
            bulletDmg: 20,
            bulletSpeed: 12,
            fireRate: 20, // ŸÉŸÑŸÖÿß ŸÇŸÑ ÿ≤ÿßÿØÿ™ ÿßŸÑÿ≥ÿ±ÿπÿ©
            bulletCount: 1, // ÿπÿØÿØ ÿßŸÑÿ±ÿµÿßÿµ (Multishot)
            spread: 0.1,
            pierce: 0 // ÿßÿÆÿ™ÿ±ÿßŸÇ
        };

        // ŸÖÿµŸÅŸàŸÅÿßÿ™ ÿßŸÑŸÉÿßÿ¶ŸÜÿßÿ™
        let enemies = [];
        let bullets = [];
        let particles = [];
        let xpOrbs = [];
        let damageTexts = [];

        // === ÿßŸÑŸÖÿØÿÆŸÑÿßÿ™ ===
        const input = {
            active: false,
            sx: 0, sy: 0, // Start X, Y
            cx: 0, cy: 0, // Current X, Y
            dx: 0, dy: 0, // Normalized vector
            id: null
        };

        // ========================
        // ŸÜÿ∏ÿßŸÖ ÿßŸÑÿ™ÿ±ŸÇŸäÿßÿ™ (ROGUELIKE)
        // ========================
        const upgradesList = [
            { id: 'multishot', name: 'DOUBLE BARREL', desc: '+1 Bullet per shot', icon: 'üî´', apply: () => { player.bulletCount++; player.spread += 0.1; } },
            { id: 'dmg', name: 'HIGH VOLTAGE', desc: '+25% Damage', icon: '‚ö°', apply: () => { player.bulletDmg = Math.floor(player.bulletDmg * 1.25); } },
            { id: 'speed', name: 'OVERCLOCK', desc: '+15% Fire Rate', icon: 'üî•', apply: () => { player.fireRate = Math.max(5, Math.floor(player.fireRate * 0.85)); } },
            { id: 'heal', name: 'REPAIR BOT', desc: 'Recover 50% HP', icon: '‚ù§Ô∏è', apply: () => { player.hp = Math.min(player.maxHp, player.hp + (player.maxHp*0.5)); } },
            { id: 'move', name: 'THRUSTERS', desc: '+10% Move Speed', icon: 'üöÄ', apply: () => { player.speed *= 1.1; } },
            { id: 'pierce', name: 'RAILGUN', desc: 'Bullets pierce 1 enemy', icon: 'üèπ', apply: () => { player.pierce++; } }
        ];

        function showUpgradeScreen() {
            gameState = 'UPGRADE';
            const box = document.getElementById('cards-box');
            box.innerHTML = '';
            
            // ÿßÿÆÿ™Ÿäÿßÿ± 3 ÿ™ÿ±ŸÇŸäÿßÿ™ ÿπÿ¥Ÿàÿßÿ¶Ÿäÿ©
            for(let i=0; i<3; i++) {
                const upg = upgradesList[Math.floor(Math.random() * upgradesList.length)];
                const div = document.createElement('div');
                div.className = 'upgrade-card';
                div.innerHTML = `<div class="icon">${upg.icon}</div><div class="desc"><h3>${upg.name}</h3><span>${upg.desc}</span></div>`;
                div.onclick = () => {
                    upg.apply();
                    document.getElementById('upgrade-screen').style.display = 'none';
                    gameState = 'PLAY';
                    createFloatingText(player.x, player.y - 30, "SYSTEM UPGRADED", '#0f0', 20);
                };
                box.appendChild(div);
            }
            document.getElementById('upgrade-screen').style.display = 'flex';
        }

        // ========================
        // ÿßŸÑŸÉŸÑÿßÿ≥ÿßÿ™
        // ========================
        class Enemy {
            constructor(type) {
                // ÿ£ŸÜŸàÿßÿπ ÿßŸÑÿ£ÿπÿØÿßÿ°: 0:Chaser, 1:Tank, 2:Shooter
                this.type = type;
                let angle = Math.random() * Math.PI * 2;
                let dist = Math.max(width, height) * 0.8;
                this.x = player.x + Math.cos(angle) * dist;
                this.y = player.y + Math.sin(angle) * dist;
                
                if(type === 0) { // Chaser
                    this.hp = 30 + (player.level * 5);
                    this.speed = 3 + (Math.random());
                    this.radius = 12;
                    this.color = '#ff0055';
                    this.xp = 10;
                } else if (type === 1) { // Tank
                    this.hp = 100 + (player.level * 15);
                    this.speed = 1.5;
                    this.radius = 25;
                    this.color = '#ffaa00';
                    this.xp = 30;
                } else { // Shooter
                    this.hp = 40 + (player.level * 8);
                    this.speed = 2;
                    this.radius = 15;
                    this.color = '#aa00ff';
                    this.xp = 20;
                    this.shootTimer = 0;
                }
                this.maxHp = this.hp;
            }

            update() {
                let dx = player.x - this.x;
                let dy = player.y - this.y;
                let dist = Math.hypot(dx, dy);
                let angle = Math.atan2(dy, dx);

                if(this.type === 2) { // Shooter Logic
                    if(dist > 250) {
                        this.x += Math.cos(angle) * this.speed;
                        this.y += Math.sin(angle) * this.speed;
                    } else if (dist < 150) {
                        this.x -= Math.cos(angle) * this.speed;
                        this.y -= Math.sin(angle) * this.speed;
                    }
                    this.shootTimer++;
                    if(this.shootTimer > 100) {
                        this.shootTimer = 0;
                        // ÿ±ÿµÿßÿµÿ© ÿßŸÑÿπÿØŸà
                        bullets.push({
                            x: this.x, y: this.y, 
                            vx: Math.cos(angle)*6, vy: Math.sin(angle)*6, 
                            color: '#aa00ff', owner: 'enemy', dmg: 10, radius: 4, life: 100
                        });
                    }
                } else { // Melee Logic
                    this.x += Math.cos(angle) * this.speed;
                    this.y += Math.sin(angle) * this.speed;
                    if(dist < this.radius + player.radius) {
                        player.hp -= 0.5; // ÿ∂ÿ±ÿ± ÿßŸÑÿ™ŸÑÿßŸÖÿ≥
                        createParticles(this.x, this.y, '#f00', 1);
                        shake = 5;
                    }
                }
            }

            draw() {
                ctx.save(); ctx.translate(this.x, this.y);
                ctx.fillStyle = this.color; ctx.shadowBlur = 10; ctx.shadowColor = this.color;
                
                if(this.type === 1) ctx.fillRect(-this.radius, -this.radius, this.radius*2, this.radius*2); // Tank ŸÖÿ±ÿ®ÿπ
                else if (this.type === 2) { // Shooter ŸÖÿ´ŸÑÿ´
                    ctx.rotate(Math.atan2(player.y - this.y, player.x - this.x));
                    ctx.beginPath(); ctx.moveTo(15,0); ctx.lineTo(-10, 10); ctx.lineTo(-10, -10); ctx.fill();
                } else { // Chaser ÿØÿßÿ¶ÿ±ÿ©
                    ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI*2); ctx.fill();
                }
                ctx.restore();
            }
        }

        class XpOrb {
            constructor(x, y, amount) {
                this.x = x; this.y = y; this.amount = amount;
                this.magnet = false;
            }
            update() {
                let dx = player.x - this.x; let dy = player.y - this.y;
                let dist = Math.hypot(dx, dy);
                if(dist < 150) this.magnet = true; // ÿ¨ÿ∞ÿ® ŸÖÿ∫ŸÜÿßÿ∑Ÿäÿ≥Ÿä
                
                if(this.magnet) {
                    this.x += (dx/dist) * 12;
                    this.y += (dy/dist) * 12;
                    if(dist < player.radius + 10) {
                        addXp(this.amount);
                        return true; // Picked up
                    }
                }
                return false;
            }
            draw() {
                ctx.fillStyle = '#00ff00'; ctx.shadowBlur = 5; ctx.shadowColor = '#00ff00';
                ctx.beginPath(); ctx.arc(this.x, this.y, 4, 0, Math.PI*2); ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        class FloatingText {
            constructor(x, y, text, color, size) {
                this.x = x; this.y = y; this.text = text; this.color = color; this.size = size;
                this.life = 60; this.vy = -1;
            }
            update() {
                this.y += this.vy; this.life--;
                return this.life <= 0;
            }
            draw() {
                ctx.globalAlpha = this.life / 60;
                ctx.fillStyle = this.color; ctx.font = `bold ${this.size}px monospace`;
                ctx.fillText(this.text, this.x, this.y);
                ctx.globalAlpha = 1;
            }
        }

        // ========================
        // ÿßŸÑŸàÿ∏ÿßÿ¶ŸÅ ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿäÿ©
        // ========================

        function createParticles(x, y, color, count) {
            for(let i=0; i<count; i++) particles.push({x, y, vx:(Math.random()-0.5)*10, vy:(Math.random()-0.5)*10, life:1, color});
        }

        function createFloatingText(x, y, text, color, size=14) {
            damageTexts.push(new FloatingText(x + (Math.random()*20-10), y, text, color, size));
        }

        function addXp(amount) {
            player.xp += amount;
            if(player.xp >= player.nextLevelXp) {
                player.xp -= player.nextLevelXp;
                player.level++;
                player.nextLevelXp = Math.floor(player.nextLevelXp * 1.5);
                document.getElementById('lvl-txt').innerText = player.level;
                showUpgradeScreen();
            }
            updateUi();
        }

        function updateUi() {
            // ÿ¥ÿ±Ÿäÿ∑ XP
            let xpPerc = (player.xp / player.nextLevelXp) * 100;
            document.getElementById('xp-fill').style.width = xpPerc + "%";
            // ÿ¥ÿ±Ÿäÿ∑ ÿµÿ≠ÿ©
            let hpPerc = (player.hp / player.maxHp) * 100;
            document.getElementById('hp-fill').style.width = hpPerc + "%";
            document.getElementById('kill-count').innerText = kills;
        }

        let shake = 0;
        function applyShake() {
            if(shake > 0) {
                ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake);
                shake *= 0.9;
            }
        }

        // ========================
        // ÿ≠ŸÑŸÇÿ© ÿßŸÑŸÑÿπÿ®ÿ©
        // ========================

        function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            player.x = width/2; player.y = height/2;
            player.hp = 100; player.level = 1; player.xp = 0;
            enemies = []; bullets = []; xpOrbs = [];
            bgMusic.play().catch(()=>{});
            gameState = 'PLAY';
            loop();
        }

        function loop() {
            requestAnimationFrame(loop);
            if(gameState !== 'PLAY') return;
            frame++;

            // ŸÖÿ≥ÿ≠ ÿßŸÑÿ¥ÿßÿ¥ÿ© ŸÖÿπ ÿ™ÿ£ÿ´Ÿäÿ± ÿ∞ŸäŸÑ ÿÆŸÅŸäŸÅ (Motion Blur)
            ctx.fillStyle = 'rgba(5, 5, 5, 0.3)'; 
            ctx.fillRect(0, 0, width, height);

            ctx.save();
            applyShake();

            // 1. ÿ•ÿØÿßÿ±ÿ© ÿßŸÑÿ£ÿπÿØÿßÿ° (Spawner)
            let maxEnemies = 5 + player.level * 2;
            if(enemies.length < maxEnemies) {
                // ÿ£ŸÜŸàÿßÿπ ŸÖÿÆÿ™ŸÑŸÅÿ© ÿ≠ÿ≥ÿ® ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ
                let type = 0; 
                if(player.level > 2 && Math.random() < 0.2) type = 2; // Shooter
                if(player.level > 4 && Math.random() < 0.1) type = 1; // Tank
                enemies.push(new Enemy(type));
            }

            // 2. ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÑÿßÿπÿ®
            if(input.active) {
                // ÿßŸÑÿ≠ÿ±ŸÉÿ©
                player.x += input.dx * player.speed;
                player.y += input.dy * player.speed;
                // ÿßŸÑÿ®ŸÇÿßÿ° ŸÅŸä ÿßŸÑÿ≠ÿØŸàÿØ
                player.x = Math.max(20, Math.min(width-20, player.x));
                player.y = Math.max(20, Math.min(height-20, player.y));

                // ÿßŸÑÿ•ÿ∑ŸÑÿßŸÇ ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿä
                if(frame % player.fireRate === 0) {
                    // ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ÿ£ŸÇÿ±ÿ® ÿπÿØŸà
                    let nearest = null, minDist = 9999;
                    enemies.forEach(e => {
                        let d = Math.hypot(e.x - player.x, e.y - player.y);
                        if(d < minDist) { minDist = d; nearest = e; }
                    });
                    
                    let targetAngle = input.dy || input.dx ? Math.atan2(input.dy, input.dx) : 0;
                    if(nearest && minDist < 400) targetAngle = Math.atan2(nearest.y - player.y, nearest.x - player.x);

                    // Multi-shot logic
                    for(let i=0; i<player.bulletCount; i++) {
                        let offset = (i - (player.bulletCount-1)/2) * player.spread;
                        bullets.push({
                            x: player.x, y: player.y, 
                            vx: Math.cos(targetAngle+offset)*player.bulletSpeed, vy: Math.sin(targetAngle+offset)*player.bulletSpeed, 
                            color: '#00f3ff', owner: 'player', dmg: player.bulletDmg, radius: 4, life: 100, pierce: player.pierce
                        });
                    }
                }
            }

            // ÿ±ÿ≥ŸÖ ÿßŸÑŸÑÿßÿπÿ®
            ctx.shadowBlur = 15; ctx.shadowColor = '#00f3ff'; ctx.fillStyle = '#00f3ff';
            ctx.beginPath(); ctx.arc(player.x, player.y, player.radius, 0, Math.PI*2); ctx.fill();
            ctx.shadowBlur = 0;

            // 3. ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÉŸäÿßŸÜÿßÿ™
            // XP Orbs
            xpOrbs = xpOrbs.filter(o => { o.draw(); return !o.update(); });
            
            // Text
            damageTexts = damageTexts.filter(t => { t.draw(); return !t.update(); });

            // Particles
            for(let i=particles.length-1; i>=0; i--) {
                let p = particles[i]; p.x += p.vx; p.y += p.vy; p.life -= 0.05;
                ctx.globalAlpha = p.life; ctx.fillStyle = p.color; 
                ctx.beginPath(); ctx.arc(p.x, p.y, 2, 0, Math.PI*2); ctx.fill();
                ctx.globalAlpha = 1; if(p.life<=0) particles.splice(i,1);
            }

            // Enemies
            enemies.forEach((e, ei) => {
                e.update(); e.draw();
            });

            // Bullets
            for(let i=bullets.length-1; i>=0; i--) {
                let b = bullets[i]; 
                b.x += b.vx; b.y += b.vy; b.life--;
                
                ctx.fillStyle = b.color; ctx.shadowBlur = 5; ctx.shadowColor = b.color;
                ctx.beginPath(); ctx.arc(b.x, b.y, b.radius, 0, Math.PI*2); ctx.fill(); ctx.shadowBlur = 0;

                if(b.x<0||b.x>width||b.y<0||b.y>height||b.life<=0) { bullets.splice(i,1); continue; }

                // ÿ™ÿµÿßÿØŸÖ
                if(b.owner === 'player') {
                    for(let j=enemies.length-1; j>=0; j--) {
                        let e = enemies[j];
                        if(Math.hypot(b.x-e.x, b.y-e.y) < b.radius + e.radius) {
                            e.hp -= b.dmg;
                            createFloatingText(e.x, e.y, b.dmg, '#fff'); // ÿ±ŸÇŸÖ ÿßŸÑÿ∂ÿ±ÿ±
                            createParticles(e.x, e.y, b.color, 3);
                            
                            if(e.hp <= 0) {
                                xpOrbs.push(new XpOrb(e.x, e.y, e.xp));
                                createParticles(e.x, e.y, e.color, 10);
                                enemies.splice(j, 1);
                                kills++; shake = 5;
                            }
                            
                            if(b.pierce > 0) { b.pierce--; } else { bullets.splice(i,1); }
                            break;
                        }
                    }
                } else { // ÿ±ÿµÿßÿµ ÿßŸÑÿπÿØŸà
                    if(Math.hypot(b.x-player.x, b.y-player.y) < b.radius + player.radius) {
                        player.hp -= b.dmg;
                        createFloatingText(player.x, player.y, "-"+b.dmg, '#f00', 18);
                        shake = 10;
                        createParticles(player.x, player.y, '#f00', 5);
                        bullets.splice(i,1);
                    }
                }
            }

            // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑŸÖŸàÿ™
            updateUi();
            if(player.hp <= 0) {
                gameState = 'OVER';
                document.getElementById('final-score').innerText = kills;
                document.getElementById('final-level').innerText = player.level;
                document.getElementById('game-over-screen').style.display = 'flex';
            }

            // ÿ±ÿ≥ŸÖ ÿßŸÑÿ¨ŸàŸäÿ≥ÿ™ŸäŸÉ
            if(input.active) {
                ctx.strokeStyle = 'rgba(255,255,255,0.2)'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(input.sx, input.sy, 50, 0, Math.PI*2); ctx.stroke();
                ctx.fillStyle = 'rgba(0, 243, 255, 0.5)';
                ctx.beginPath(); ctx.arc(input.cx, input.cy, 20, 0, Math.PI*2); ctx.fill();
            }

            ctx.restore();
        }

        // === ÿßŸÑÿ™ÿ≠ŸÉŸÖ ÿ®ÿßŸÑŸÑŸÖÿ≥ ===
        window.addEventListener('touchstart', e => {
            if(e.target.tagName === 'BUTTON' || e.target.closest('.upgrade-card')) return;
            e.preventDefault();
            if(!input.active && gameState === 'PLAY') {
                let t = e.changedTouches[0];
                input.active = true; input.id = t.identifier;
                input.sx = t.clientX; input.sy = t.clientY;
                input.cx = t.clientX; input.cy = t.clientY;
            }
        }, {passive: false});

        window.addEventListener('touchmove', e => {
            if(gameState !== 'PLAY') return;
            e.preventDefault();
            for(let i=0; i<e.changedTouches.length; i++) {
                if(e.changedTouches[i].identifier === input.id) {
                    let t = e.changedTouches[i];
                    let dx = t.clientX - input.sx; let dy = t.clientY - input.sy;
                    let dist = Math.min(50, Math.hypot(dx, dy));
                    let angle = Math.atan2(dy, dx);
                    input.cx = input.sx + Math.cos(angle) * dist;
                    input.cy = input.sy + Math.sin(angle) * dist;
                    input.dx = Math.cos(angle) * (dist/50);
                    input.dy = Math.sin(angle) * (dist/50);
                }
            }
        }, {passive: false});

        window.addEventListener('touchend', e => {
            for(let i=0; i<e.changedTouches.length; i++) {
                if(e.changedTouches[i].identifier === input.id) {
                    input.active = false; input.dx = 0; input.dy = 0;
                }
            }
        });

    </script>
</body>
</html>
