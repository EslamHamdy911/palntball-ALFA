<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEON WARS: Survival</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿ¥ÿßÿ¥ÿ© ŸàÿßŸÑŸÑŸÖÿ≥ */
        * { touch-action: none; -webkit-touch-callout: none; -webkit-user-select: none; user-select: none; outline: none; -webkit-tap-highlight-color: transparent; }
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Orbitron', sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 5, 10, 0.98);
            display: flex; flex-direction: column;
            justify-content: center; align-items: center; 
            pointer-events: auto; z-index: 100;
        }
        
        h1 { color: #00f3ff; text-shadow: 0 0 20px #00f3ff; font-size: 35px; margin: 0; text-align: center;}
        p { color: #aaa; margin-top: 5px; font-size: 14px; }

        .btn {
            background: rgba(0, 243, 255, 0.1); border: 2px solid #00f3ff; color: #00f3ff;
            padding: 15px 40px; font-size: 20px; font-family: 'Orbitron', sans-serif;
            cursor: pointer; margin-top: 25px; text-transform: uppercase; width: 70%; border-radius: 10px;
            box-shadow: 0 0 15px #00f3ff; pointer-events: auto;
        }
        .btn:active { background: #00f3ff; color: #000; transform: scale(0.95); }

        /* ÿ¥ÿßÿ¥ÿ© ÿßŸÑÿÆÿ≥ÿßÿ±ÿ© */
        #game-over-screen {
            background: rgba(20, 0, 0, 0.95);
            display: none;
        }
        #game-over-screen h1 { color: #ff0000; text-shadow: 0 0 30px #ff0000; font-size: 50px; }
        .btn-red { border-color: #ff0000; color: #ff0000; box-shadow: 0 0 15px #ff0000; background: rgba(255, 0, 0, 0.1); }

        /* ÿ≤ÿ± ÿßŸÑÿ∫ÿ∂ÿ® */
        #rage-btn {
            position: absolute; bottom: 50px; right: 20px;
            width: 90px; height: 90px; border-radius: 50%;
            background: radial-gradient(circle, #ff5500, #550000);
            border: 4px solid #ffaa00;
            color: #fff; font-weight: bold; font-size: 16px;
            display: none; 
            justify-content: center; align-items: center;
            box-shadow: 0 0 20px #ff5500;
            animation: pulseRage 0.5s infinite alternate;
            pointer-events: auto; cursor: pointer; z-index: 200;
        }
        @keyframes pulseRage { from { transform: scale(1); box-shadow: 0 0 20px #ff5500; } to { transform: scale(1.1); box-shadow: 0 0 40px #ff5500; } }

        #hud { padding: 15px; display: flex; justify-content: space-between; width: 90%; margin: 0 auto; text-shadow: 0 2px 5px rgba(0,0,0,0.8); font-size: 16px; font-weight: bold; }
        #wave-msg { position: absolute; top: 15%; width: 100%; text-align: center; color: #f1c40f; font-size: 24px; font-weight: bold; opacity: 0; transition: opacity 0.5s; text-shadow: 0 0 10px #f00; }
        
        #rage-timer { position: absolute; top: 60px; right: 20px; color: #ff5500; font-size: 14px; font-weight: bold;}
    </style>
</head>
<body>

    <div id="start-screen" class="screen">
        <h1>NEON WARS</h1>
        <p>SURVIVAL MODE</p>
        <button class="btn" onclick="startGame()">START</button>
        <p style="margin-top: 20px; font-size: 10px; color: #666;">KILL 10 TO HEAL</p>
    </div>

    <!-- ÿ¥ÿßÿ¥ÿ© ÿßŸÑÿÆÿ≥ÿßÿ±ÿ© -->
    <div id="game-over-screen" class="screen">
        <h1>GAME OVER</h1>
        <p>SCORE: <span id="final-score">0</span></p>
        <button class="btn btn-red" onclick="location.reload()">TRY AGAIN</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div id="hud">
            <div style="color:#00f3ff">KILLS: <span id="p-score">0</span></div>
            <div style="color:#ff0055">HP: <span id="p-hp">100</span>%</div>
        </div>
        <div id="wave-msg">WARNING</div>
        <div id="rage-timer">RAGE: <span id="r-time">0</span>%</div>
        <div id="rage-btn">RAGE!</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        function resize() {
            width = window.innerWidth; height = window.innerHeight;
            canvas.width = width; canvas.height = height;
        }
        window.addEventListener('resize', resize); resize();

        let gameRunning = false;
        let score = 0;
        let killCounterForHeal = 0; // ÿπÿØÿßÿØ ŸÑŸÑÿ¥ŸÅÿßÿ°
        let frame = 0;
        
        let enemies = [], bullets = [], particles = [];
        let player;
        let shake = 0;
        
        let bossPhase = 0; 
        let rageCharge = 100;
        let isRageActive = false;
        let rageDuration = 0;

        const input = {
            active: false,
            startX: 0, startY: 0,
            x: 0, y: 0,
            dx: 0, dy: 0,
            id: null
        };

        class Agent {
            constructor(x, y, type) {
                this.x = x; this.y = y; this.type = type; 
                this.angle = 0;
                
                if(type === 'player') {
                    this.radius = 15; this.color = '#00f3ff'; this.speed = 4; 
                    this.hp = 100; this.maxHp = 100; // ÿµÿ≠ÿ© ÿßŸÑŸÑÿßÿπÿ®
                } else if (type === 'boss') {
                    this.radius = 40; this.color = '#f1c40f'; this.speed = 1.5; this.hp = 500; this.maxHp = 500;
                } else if (type === 'zombie') {
                    this.radius = 15; this.color = '#00ff00'; this.speed = 5; this.hp = 20;
                } else { 
                    this.radius = 15; this.color = '#ff0055'; this.speed = 2.5; this.hp = 40;
                }
            }

            update() {
                let dx=0, dy=0;
                if (this.type === 'player') {
                    if (input.active) {
                        dx = input.dx; dy = input.dy;
                        let nearest = null; let minDst = 9999;
                        enemies.forEach(e => {
                            let d = Math.hypot(e.x - this.x, e.y - this.y);
                            if(d < minDst) { minDst = d; nearest = e; }
                        });
                        if(nearest && minDst < 500) {
                            this.angle = Math.atan2(nearest.y - this.y, nearest.x - this.x);
                        } else if (dx || dy) {
                            this.angle = Math.atan2(dy, dx);
                        }
                        let rate = isRageActive ? 5 : 12; 
                        if(frame % rate === 0) shoot(this);
                    }
                } else {
                    let target = player;
                    let dist = Math.hypot(target.x - this.x, target.y - this.y);
                    this.angle = Math.atan2(target.y - this.y, target.x - this.x);

                    if(this.type === 'zombie') {
                        dx = Math.cos(this.angle); dy = Math.sin(this.angle);
                        if(dist < this.radius + target.radius) {
                            player.hp -= 0.5; // ÿ∂ÿ±ÿ± ŸÖÿ≥ÿ™ŸÖÿ±
                            createExplosion(this.x, this.y, '#f00', 1);
                            checkGameOver(); // ŸÅÿ≠ÿµ ÿßŸÑŸÖŸàÿ™
                        }
                    } else {
                        let stopDist = (this.type === 'boss') ? 250 : 150;
                        if(dist > stopDist) { dx = Math.cos(this.angle); dy = Math.sin(this.angle); }
                        else if(dist < stopDist - 50) { dx = -Math.cos(this.angle); dy = -Math.sin(this.angle); }
                        
                        enemies.forEach(other => {
                            if(other !== this && Math.hypot(this.x - other.x, this.y - other.y) < this.radius + other.radius) {
                                dx += (this.x - other.x) * 0.05; dy += (this.y - other.y) * 0.05;
                            }
                        });

                        let shootProb = (this.type === 'boss') ? 0.03 : 0.02;
                        if(Math.random() < shootProb) shoot(this);
                    }
                }
                this.x += dx * this.speed; this.y += dy * this.speed;
                this.x = Math.max(20, Math.min(width-20, this.x));
                this.y = Math.max(20, Math.min(height-20, this.y));
            }

            draw() {
                ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
                let drawColor = (this.type === 'player' && isRageActive) ? '#ff4400' : this.color;
                ctx.shadowBlur = 10; ctx.shadowColor = drawColor;
                ctx.fillStyle = drawColor; ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI*2); ctx.fill();
                ctx.shadowBlur = 0; ctx.fillStyle = '#111';
                
                if(this.type === 'boss') {
                    ctx.fillRect(15, -30, 40, 60); ctx.beginPath(); ctx.arc(0, 0, 25, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = 'red'; ctx.fillRect(-30, -50, 60, 4);
                    ctx.fillStyle = '#0f0'; ctx.fillRect(-30, -50, 60 * (this.hp/this.maxHp), 4);
                } else if(this.type === 'zombie') {
                     ctx.beginPath(); ctx.arc(5, -5, 4, 0, Math.PI*2); ctx.fill();
                     ctx.beginPath(); ctx.arc(5, 5, 4, 0, Math.PI*2); ctx.fill();
                } else {
                    ctx.fillRect(5, -5, 15, 10);
                }
                ctx.restore();
            }
        }

        function spawnEnemy(type = 'enemy') {
            let startX = width/2;
            let startY = -50;
            if(type === 'zombie') {
                startX = Math.random() < 0.5 ? -20 : width+20;
                startY = Math.random() * height;
            } else if (type === 'enemy') {
                startX = Math.random() * width;
            }
            let e = new Agent(startX, startY, type);
            enemies.push(e);
        }

        function shoot(s) {
            let shots = [];
            if(s.type === 'player') {
                if(isRageActive) { shots.push(s.angle, s.angle-0.2, s.angle+0.2); } 
                else { shots.push(s.angle); }
            } else if(s.type === 'boss') {
                shots.push(s.angle, s.angle-0.3, s.angle+0.3);
            } else {
                shots.push(s.angle + (Math.random()-0.5)*0.1);
            }
            shots.forEach(a => {
                let size = (s.type === 'player' && isRageActive) ? 6 : 3;
                let dmg = (s.type === 'player') ? (isRageActive ? 20 : 10) : 5;
                bullets.push({
                    x: s.x, y: s.y, vx: Math.cos(a)*10, vy: Math.sin(a)*10, 
                    color: (s.type === 'player' && isRageActive) ? '#ff4400' : s.color, 
                    owner: s.type === 'player' ? 'p' : 'e', size: size, damage: dmg
                });
            });
        }

        function createExplosion(x, y, color, count=10) {
            for(let i=0; i<count; i++) particles.push({x, y, vx:(Math.random()-0.5)*8, vy:(Math.random()-0.5)*8, life:1, color});
        }

        function showMsg(text) {
            let el = document.getElementById('wave-msg'); el.innerText = text; el.style.opacity = 1; setTimeout(() => el.style.opacity = 0, 3000);
        }

        // --- ŸÜÿ∏ÿßŸÖ ÿßŸÑÿ™ÿπÿ®ÿ¶ÿ© ÿßŸÑŸÑÿßŸÜŸáÿßÿ¶Ÿä (Infinite Spawning) ---
        function maintainEnemies() {
            if(bossPhase === 1 || bossPhase === 2) return;

            // ŸÉŸÑŸÖÿß ÿ≤ÿßÿØÿ™ ÿßŸÑŸÜŸÇÿßÿ∑ÿå ÿ≤ÿßÿØ ÿπÿØÿØ ÿßŸÑÿ£ÿπÿØÿßÿ° ÿßŸÑŸÖÿ≥ŸÖŸàÿ≠ ÿ®Ÿá
            let maxEnemies = 4 + Math.floor(score / 50); 
            
            if(enemies.length < maxEnemies) {
                if(enemies.length === 0) {
                    spawnEnemy(bossPhase === 3 ? 'zombie' : 'enemy');
                } else if(Math.random() < 0.05) {
                    spawnEnemy(bossPhase === 3 ? 'zombie' : 'enemy');
                }
            }
        }

        function checkProgression() {
            // ŸÖÿ±ÿßÿ≠ŸÑ ÿßŸÑŸàÿ≠Ÿàÿ¥ (ÿ™ÿ®ŸÇŸâ ŸÉŸÖÿß ŸáŸä ŸÑÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ™ÿ≠ÿØŸä)
            if(score >= 100 && bossPhase === 0) {
                bossPhase = 1; showMsg("‚ö†Ô∏è BOSS DETECTED ‚ö†Ô∏è");
                enemies = []; setTimeout(() => spawnEnemy('boss'), 1000);
            }
            else if(bossPhase === 1 && enemies.length === 0) {
                bossPhase = 2; showMsg("‚ö†Ô∏è THE TWINS ‚ö†Ô∏è");
                setTimeout(() => { spawnEnemy('boss'); spawnEnemy('boss'); }, 2000);
            }
            else if(bossPhase === 2 && enemies.length === 0 && score > 200) {
                bossPhase = 3; showMsg("‚ò£Ô∏è ENDLESS ZOMBIE HORDE ‚ò£Ô∏è");
            }
        }

        function checkGameOver() {
            if (player.hp <= 0) {
                player.hp = 0;
                gameRunning = false;
                document.getElementById('final-score').innerText = score;
                document.getElementById('game-over-screen').style.display = 'flex';
                document.getElementById('ui-layer').style.display = 'none';
            }
        }

        // --- Rage ---
        function activateRage() {
            isRageActive = true; rageDuration = 600; rageCharge = 0;
            document.getElementById('rage-btn').style.display = 'none';
            showMsg("üî•üî• RAGE UNLEASHED üî•üî•");
            createExplosion(player.x, player.y, '#ff4400', 50);
            for(let i=0; i<6; i++) setTimeout(() => spawnEnemy('zombie'), i*300);
        }

        function updateRage() {
            if(isRageActive) {
                rageDuration--;
                if(rageDuration <= 0) { isRageActive = false; }
            } else {
                if(rageCharge < 100) rageCharge += (100 / 1800);
                document.getElementById('r-time').innerText = Math.floor(rageCharge);
                if(rageCharge >= 100) document.getElementById('rage-btn').style.display = 'flex';
            }
        }

        function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            player = new Agent(width/2, height-100, 'player');
            enemies = []; bullets = []; score = 0; killCounterForHeal = 0; 
            bossPhase = 0; rageCharge = 100;
            gameRunning = true; 
            spawnEnemy(); 
            loop();
        }

        function loop() {
            if(!gameRunning) return;
            requestAnimationFrame(loop); frame++;
            
            if(shake > 0) { ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake); shake *= 0.9; }

            ctx.fillStyle = '#050505'; ctx.fillRect(0,0,width,height);
            ctx.strokeStyle = 'rgba(0, 243, 255, 0.05)'; ctx.lineWidth = 1; ctx.beginPath();
            for(let i=0; i<width; i+=80) { ctx.moveTo(i,0); ctx.lineTo(i,height); }
            for(let i=0; i<height; i+=80) { ctx.moveTo(0,i); ctx.lineTo(width,i); }
            ctx.stroke();

            updateRage();
            maintainEnemies();

            for(let i=particles.length-1; i>=0; i--) {
                let p = particles[i]; p.x += p.vx; p.y += p.vy; p.life -= 0.05;
                ctx.globalAlpha = p.life; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, 2, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1; if(p.life<=0) particles.splice(i,1);
            }

            if(player) player.update(); player.draw();
            enemies.forEach(e => { e.update(); e.draw(); });

            for(let i=bullets.length-1; i>=0; i--) {
                let b = bullets[i]; b.x += b.vx; b.y += b.vy;
                ctx.strokeStyle = b.color; ctx.lineWidth = b.size; ctx.beginPath(); ctx.moveTo(b.x, b.y); ctx.lineTo(b.x-b.vx, b.y-b.vy); ctx.stroke();
                
                if(b.x<0||b.x>width||b.y<0||b.y>height) { bullets.splice(i,1); continue; }

                let targets = (b.owner === 'p') ? enemies : [player];
                for(let t of targets) {
                    if(Math.hypot(b.x-t.x, b.y-t.y) < t.radius+5) {
                        createExplosion(t.x, t.y, b.color, 3);
                        if(b.owner === 'p') {
                            t.hp -= b.damage;
                            if(t.hp <= 0) {
                                score += (t.type==='boss'?50:1); 
                                
                                // --- ŸÜÿ∏ÿßŸÖ ÿßŸÑÿ¥ŸÅÿßÿ° ---
                                killCounterForHeal++;
                                if(killCounterForHeal >= 10) {
                                    killCounterForHeal = 0;
                                    player.hp = Math.min(player.hp + 25, player.maxHp); // ÿ¥ŸÅÿßÿ° 25%
                                    showMsg("‚ù§Ô∏è HP RECOVERED ‚ù§Ô∏è");
                                }
                                // -------------------

                                createExplosion(t.x, t.y, '#fff', 10);
                                enemies = enemies.filter(e => e !== t);
                                checkProgression();
                            }
                        } else {
                            player.hp -= 3; shake = 5; // ÿ∂ÿ±ÿ± ÿßŸÑŸÑÿßÿπÿ®
                            checkGameOver(); // ŸÅÿ≠ÿµ ÿßŸÑŸÖŸàÿ™
                        }
                        bullets.splice(i,1); break;
                    }
                }
            }

            document.getElementById('p-score').innerText = score;
            document.getElementById('p-hp').innerText = Math.max(0, Math.floor((player.hp/player.maxHp)*100));

            if (input.active) {
                ctx.beginPath(); ctx.arc(input.startX, input.startY, 40, 0, Math.PI*2);
                ctx.strokeStyle = 'rgba(255,255,255,0.1)'; ctx.stroke();
                ctx.beginPath(); ctx.arc(input.x, input.y, 20, 0, Math.PI*2);
                ctx.fillStyle = 'rgba(0, 243, 255, 0.4)'; ctx.fill();
            }

            ctx.restore();
        }

        // --- ÿßŸÑÿ™ÿ≠ŸÉŸÖ ---
        const rageBtn = document.getElementById('rage-btn');
        rageBtn.addEventListener('touchstart', (e) => { e.stopPropagation(); activateRage(); });
        rageBtn.addEventListener('click', (e) => { e.stopPropagation(); activateRage(); });

        window.addEventListener('touchstart', e => {
            if(e.target.tagName === 'BUTTON' || e.target.id === 'rage-btn') return;
            e.preventDefault();
            if(!input.active) {
                let t = e.changedTouches[0];
                input.active = true;
                input.id = t.identifier;
                input.startX = t.clientX; input.startY = t.clientY;
                input.x = t.clientX; input.y = t.clientY;
                input.dx = 0; input.dy = 0;
            }
        }, {passive: false});

        window.addEventListener('touchmove', e => {
            if(e.target.tagName !== 'BUTTON' && e.target.id !== 'rage-btn') e.preventDefault();
            for(let i=0; i<e.changedTouches.length; i++) {
                let t = e.changedTouches[i];
                if(input.active && t.identifier === input.id) {
                    let dx = t.clientX - input.startX;
                    let dy = t.clientY - input.startY;
                    let dist = Math.min(40, Math.hypot(dx, dy));
                    let angle = Math.atan2(dy, dx);
                    input.x = input.startX + Math.cos(angle) * dist;
                    input.y = input.startY + Math.sin(angle) * dist;
                    input.dx = Math.cos(angle) * (dist/40);
                    input.dy = Math.sin(angle) * (dist/40);
                }
            }
        }, {passive: false});

        window.addEventListener('touchend', e => {
             for(let i=0; i<e.changedTouches.length; i++) {
                if(e.changedTouches[i].identifier === input.id) {
                    input.active = false; input.dx = 0; input.dy = 0;
                }
             }
        }, {passive: false});

    </script>
</body>
</html>